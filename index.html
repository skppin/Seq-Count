<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Seq Completion Tracker</title>
  <style>
    :root {
      --gap: 6px;
      --cell-size: 46px;
      --green: #2ecc71;
      --border: #d0d0d0;
    }

    body {
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      margin: 20px;
      color: #222;
    }

    header {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 10px 14px;
      margin-bottom: 14px;
    }

    .stats {
      display: flex;
      gap: 14px;
      align-items: center;
      padding: 10px 12px;
      border: 1px solid #eee;
      border-radius: 10px;
      background: #fafafa;
    }

    .stat { font-size: 14px; }
    .stat b { font-size: 16px; }

    button.action {
      cursor: pointer;
      border: 1px solid #ccc;
      background: white;
      padding: 10px 12px;
      border-radius: 10px;
      font-weight: 700;
    }
    button.action:hover { background: #f5f5f5; }

    .status {
      font-size: 13px;
      color: #555;
      padding-left: 4px;
    }

    /* Top row (Main + Penalty/Referee) */
    .boards {
      display: flex;
      gap: 14px;
      align-items: flex-start;
      flex-wrap: wrap; /* wraps on smaller screens */
      margin-bottom: 14px;
    }

    /* Second row (Mirror + Flip) */
    .boards-below {
      display: flex;
      gap: 14px;
      align-items: flex-start;
      flex-wrap: wrap;
    }

    .board {
      flex: 1 1 520px; /* side-by-side if space; wraps otherwise */
      border: 1px solid #eee;
      border-radius: 14px;
      padding: 14px;
      background: #fff;
      box-shadow: 0 1px 0 rgba(0,0,0,0.03);
    }

    .board h2 {
      margin: 0 0 10px 0;
      font-size: 16px;
    }

    .grid {
      display: grid;
      gap: var(--gap);
      user-select: none;
    }

    .cell {
      width: var(--cell-size);
      height: var(--cell-size);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      border: 1px solid var(--border);
      border-radius: 10px;
      background: #fff;
      font-weight: 700;
      font-size: 13px;
      transition: transform 80ms ease, background 120ms ease, border-color 120ms ease;
      box-shadow: 0 1px 0 rgba(0,0,0,0.03);
    }

    .cell:active { transform: scale(0.98); }

    .cell.green {
      background: var(--green);
      border-color: #25b864;
      color: #0b3a1e;
    }

    footer {
      margin-top: 12px;
      font-size: 12px;
      color: #666;
    }

    @media (max-width: 900px) { :root { --cell-size: 38px; } }
    @media (max-width: 650px) { :root { --cell-size: 32px; --gap: 5px; } }
  </style>
</head>

<body>
  <header>
    <div class="stats" aria-live="polite">
      <div class="stat">Completed: <b id="completedCount">0</b></div>
      <div class="stat">Remaining: <b id="remainingCount">0</b></div>
      <div class="stat">Total: <b id="totalCount">0</b></div>
    </div>

    <button class="action" id="exportTxtBtn" type="button">Export (.txt)</button>
    <button class="action" id="exportCsvBtn" type="button">Export (.csv / Excel)</button>
    <span class="status" id="syncStatus">Connecting…</span>
  </header>

  <div class="boards">
    <section class="board">
      <h2>Main Sequences</h2>
      <div id="mainGrid" class="grid" role="grid" aria-label="Main Sequence grid"></div>
    </section>

    <section class="board">
      <h2>Penalty &amp; Referee Sequences</h2>
      <div id="prGrid" class="grid" role="grid" aria-label="Penalty and Referee Sequence grid"></div>
    </section>
  </div>

  <div class="boards-below">
    <section class="board">
      <h2>Mirror Sequences</h2>
      <div id="mirrorGrid" class="grid" role="grid" aria-label="Mirror Sequences grid"></div>
    </section>

    <section class="board">
      <h2>Flip Sequences</h2>
      <div id="flipGrid" class="grid" role="grid" aria-label="Flip Sequences grid"></div>
    </section>
  </div>

  <footer>
    Shared mode: updates sync for everyone using the same page (Firebase Firestore).
  </footer>

  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.5/firebase-app.js";
    import {
      getFirestore, doc, onSnapshot, runTransaction, serverTimestamp
    } from "https://www.gstatic.com/firebasejs/10.12.5/firebase-firestore.js";

    // Using your existing Firebase config
    const firebaseConfig = {
      apiKey: "AIzaSyBQtfudSJNZb3AyQiNTDfZM0E0LwdEBm1M",
      authDomain: "seq-helper-2026.firebaseapp.com",
      projectId: "seq-helper-2026",
      storageBucket: "seq-helper-2026.firebasestorage.app",
      messagingSenderId: "724035616020",
      appId: "1:724035616020:web:bb31393c2bec91ca955601",
      measurementId: "G-YDCLDEBSYF"
    };

    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);

    // ---- Configuration ----
    const MAIN   = { key: "main",   cols: 16, total: 240, start: 1,    title: "Main Sequence" };
    const MIRROR = { key: "mirror", cols: 16, total: 240, start: 1,    title: "Mirror Sequences" };
    const FLIP   = { key: "flip",   cols: 16, total: 240, start: 1,    title: "Flip Sequences" };
    // 1000..1050 inclusive => 51 blocks
    const PR     = { key: "pr",     cols: 10, total: 51,  start: 1000, title: "Penalty & Referee Sequence" };

    const ALL = [MAIN, MIRROR, FLIP, PR];

    const GRAND_TOTAL = ALL.reduce((sum, cfg) => sum + cfg.total, 0);

    const trackerDocId = "shared_tracker_v1"; // one shared board for everyone
    const docRef = doc(db, "trackers", trackerDocId);

    // ---- UI ----
    const completedCountEl = document.getElementById("completedCount");
    const remainingCountEl = document.getElementById("remainingCount");
    const totalCountEl = document.getElementById("totalCount");
    const exportTxtBtn = document.getElementById("exportTxtBtn");
    const exportCsvBtn = document.getElementById("exportCsvBtn");
    const syncStatusEl = document.getElementById("syncStatus");

    totalCountEl.textContent = String(GRAND_TOTAL);

    const gridEls = {
      main: document.getElementById("mainGrid"),
      pr: document.getElementById("prGrid"),
      mirror: document.getElementById("mirrorGrid"),
      flip: document.getElementById("flipGrid"),
    };

    // In-memory state (synced from Firestore)
    const sets = {
      main: new Set(),    // 1..240
      mirror: new Set(),  // 1..240
      flip: new Set(),    // 1..240
      pr: new Set(),      // 1000..1050
    };

    let busy = false;

    function sanitizeIntArray(arr) {
      return Array.isArray(arr) ? arr.filter(n => Number.isInteger(n)) : [];
    }

    function updateCumulativeCounts() {
      const completed =
        sets.main.size + sets.mirror.size + sets.flip.size + sets.pr.size;

      completedCountEl.textContent = String(completed);
      remainingCountEl.textContent = String(GRAND_TOTAL - completed);
    }

    function buildGridSkeleton(gridEl, cfg, onCellClick) {
      gridEl.style.gridTemplateColumns = `repeat(${cfg.cols}, var(--cell-size))`;
      gridEl.innerHTML = "";

      const frag = document.createDocumentFragment();
      for (let i = 0; i < cfg.total; i++) {
        const value = cfg.start + i;

        const cell = document.createElement("button");
        cell.type = "button";
        cell.className = "cell";
        cell.textContent = value;
        cell.setAttribute("role", "gridcell");
        cell.dataset.value = String(value);

        cell.addEventListener("click", () => onCellClick(cfg.key, value));

        frag.appendChild(cell);
      }
      gridEl.appendChild(frag);
    }

    function applyStateToGrid(gridEl, set, cfg) {
      for (let i = 0; i < cfg.total; i++) {
        const value = cfg.start + i;
        const cell = gridEl.children[i];
        const done = set.has(value);

        cell.classList.toggle("green", done);
        cell.setAttribute("aria-pressed", done ? "true" : "false");
      }
    }

    function downloadBlob(blob, filename) {
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    }

    function getSorted(set) {
      return Array.from(set).sort((a, b) => a - b);
    }

    function exportTxt() {
      const lines = [];

      for (const cfg of ALL) {
        const list = getSorted(sets[cfg.key]);
        lines.push(cfg.title);
        lines.push(...list.map(String));
        lines.push(""); // blank line between sections
      }

      downloadBlob(
        new Blob([lines.join("\n")], { type: "text/plain;charset=utf-8" }),
        "sequences.txt"
      );
    }

    function exportCsv() {
      const lines = [];

      for (const cfg of ALL) {
        const list = getSorted(sets[cfg.key]);
        lines.push(cfg.title);
        lines.push("BlockNumber");
        lines.push(...list.map(n => String(n)));
        lines.push(""); // blank line between sections
      }

      downloadBlob(
        new Blob([lines.join("\r\n") + "\r\n"], { type: "text/csv;charset=utf-8" }),
        "sequences.csv"
      );
    }

    exportTxtBtn.addEventListener("click", exportTxt);
    exportCsvBtn.addEventListener("click", exportCsv);

    // ---- Click handling (transaction updates one shared doc) ----
    async function toggleInFirestore(whichKey, value) {
      if (busy) return;
      busy = true;
      syncStatusEl.textContent = "Saving…";

      try {
        await runTransaction(db, async (tx) => {
          const snap = await tx.get(docRef);
          const data = snap.exists() ? snap.data() : {};

          // Field mapping in Firestore doc
          const fields = {
            main: "mainCompleted",
            pr: "prCompleted",
            mirror: "mirrorCompleted",
            flip: "flipCompleted",
          };

          const mSet = new Set(sanitizeIntArray(data[fields.main]));
          const pSet = new Set(sanitizeIntArray(data[fields.pr]));
          const mirSet = new Set(sanitizeIntArray(data[fields.mirror]));
          const fSet = new Set(sanitizeIntArray(data[fields.flip]));

          const target = (k) => ({
            main: mSet,
            pr: pSet,
            mirror: mirSet,
            flip: fSet
          })[k];

          const tSet = target(whichKey);
          if (!tSet) return;

          if (tSet.has(value)) tSet.delete(value);
          else tSet.add(value);

          tx.set(docRef, {
            [fields.main]: Array.from(mSet).sort((a,b)=>a-b),
            [fields.pr]: Array.from(pSet).sort((a,b)=>a-b),
            [fields.mirror]: Array.from(mirSet).sort((a,b)=>a-b),
            [fields.flip]: Array.from(fSet).sort((a,b)=>a-b),
            updatedAt: serverTimestamp()
          }, { merge: true });
        });
      } catch (e) {
        console.error(e);
        alert("Failed to save. Check Firebase config / Firestore rules.");
      } finally {
        busy = false;
      }
    }

    // Build skeleton once
    for (const cfg of ALL) {
      buildGridSkeleton(gridEls[cfg.key], cfg, (key, value) => toggleInFirestore(key, value));
    }

    // ---- Live sync ----
    syncStatusEl.textContent = "Connecting…";
    onSnapshot(docRef, (snap) => {
      syncStatusEl.textContent = "Synced ✓";
      const data = snap.exists() ? snap.data() : {};

      const fieldByKey = {
        main: "mainCompleted",
        pr: "prCompleted",
        mirror: "mirrorCompleted",
        flip: "flipCompleted",
      };

      for (const cfg of ALL) {
        const raw = sanitizeIntArray(data[fieldByKey[cfg.key]]);
        const filtered = raw.filter(n => n >= cfg.start && n < cfg.start + cfg.total);

        sets[cfg.key] = new Set(filtered);
        applyStateToGrid(gridEls[cfg.key], sets[cfg.key], cfg);
      }

      updateCumulativeCounts();
    }, (err) => {
      console.error(err);
      syncStatusEl.textContent = "Sync error";
      alert("Sync error. Check Firebase config / Firestore rules.");
    });

    // Initial counts
    updateCumulativeCounts();
  </script>
</body>
</html>

